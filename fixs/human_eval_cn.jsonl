{"id": "50", "testing_code": "assert decode_shift('ydduxliofhm') == 'tyypsgdjach'\nassert decode_shift('kdjep') == 'fyezk'\nassert decode_shift('huxhewfbeu') == 'cpsczrawzp'"}
{"id": "38", "testing_code": "assert decode_cyclic('ihremcfoydbrk') == 'rihcemyfordbk'\nassert decode_cyclic('ydamcefyrce') == 'aydemcrfyce'\nassert decode_cyclic('mrzaoxkiotnorlduagr') == 'zmrxaookiotndrlguar'"}
{"id": "25", "testing_code": "assert factorize(2) == [2]\nassert factorize(4) == [2, 2]\nassert factorize(8) == [2, 2, 2]\nassert factorize(57) == [3, 19]\nassert factorize(3249) == [3, 3, 19, 19]\nassert factorize(185193) == [3, 3, 3, 19, 19, 19]\nassert factorize(20577) == [3, 19, 19, 19]\nassert factorize(18) == [2, 3, 3]"}
{"id": "78", "testing_code": "assert hex_key('AB') == 1, 'First test error: ' + str(hex_key('AB'))\nassert hex_key('1077E') == 2, 'Second test error: ' + str(hex_key('1077E'))\nassert hex_key('ABED1A33') == 4, 'Third test error: ' + str(hex_key(\n    'ABED1A33'))\nassert hex_key('2020') == 2, 'Fourth test error: ' + str(hex_key('2020'))\nassert hex_key('123456789ABCDEF0') == 6, 'Fifth test error: ' + str(hex_key\n    ('123456789ABCDEF0'))\nassert hex_key('112233445566778899AABBCCDDEEFF00'\n    ) == 12, 'Sixth test error: ' + str(hex_key(\n    '112233445566778899AABBCCDDEEFF00'))\nassert hex_key('') == 0"}
{"id": "2", "testing_code": "assert truncate_number(3.5) == 0.5\nassert truncate_number(1.45022) == 0.45022\nassert truncate_number(123.0001) == 0.0001", "solution": "def truncate_number(number: float) -> float:\n    _, decimal_value = str(number).split('.')\n    return float(f'.{decimal_value}')\n"}
{"id": "4", "testing_code": "assert mean_absolute_deviation([2.0,4.0]) == 1.0\nassert mean_absolute_deviation([1.0, 2.0, 3.0, 4.0]) == 1.0\nassert mean_absolute_deviation([1.0, 2.0, 3.0, 4.0, 5.0]) == 1.2"}
{"id": "33", "testing_code": "assert sort_third([1, 2, 3]) == [1, 2, 3]\nassert sort_third([5, 6, 3, 4, 8, 9, 2]) == [2, 6, 3, 4, 8, 9, 5]\nassert sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [1, 3, -5, 2, -3, 3, 5, 0, 123, 9, -10]\nassert sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-10, 8, -12, 3, 23, 2, 4, 11, 12, 5]\nassert sort_third([5, 8, 3, 4, 6, 9, 2]) == [2, 8, 3, 4, 6, 9, 5]\nassert sort_third([5, 6, 9, 4, 8, 3, 2]) == [2, 6, 9, 4, 8, 3, 5]\nassert sort_third([5, 6, 3, 4, 8, 9, 2, 1]) == [2, 6, 3, 4, 8, 9, 5, 1]", "solution": "from typing import List\ndef sort_third(l: List):\n    l = list(l)\n    l[::3] = sorted(l[::3])\n    return list(l)\n"}
{"id": "22", "testing_code": "assert filter_integers([]) == []\nassert filter_integers(['4', '{}', '[]', '23.2', '9', 'adasd']) == [4, 9]\nassert filter_integers(['3', 'c', '3', '3', 'a', 'b']) == [3, 3, 3]", "solution": "from typing import List, Any\ndef filter_integers(values: List[str]) -> List[int]:\n    integers = []\n    for x in values:\n      if x.isnumeric() and float(x).is_integer():\n        integers.append(int(x))\n    return integers\n", "text": "对于给定的任意值列表，筛选出整数值。\n>>> filter_integers([\"a\", \"3.14\", \"5\"])\n[5]\n>>> filter_integers([\"1\", \"2\", \"3\", \"abc\", \"{}\", \"[]\"])\n[1, 2, 3]\n"}
{"id": "16", "testing_code": "assert count_distinct_characters('') == 0\nassert count_distinct_characters('abcde') == 5\nassert count_distinct_characters('abcdecadeCADE') == 5\nassert count_distinct_characters('aaaaAAAAaaaa') == 1\nassert count_distinct_characters('Jerry jERRY JeRRRY') == 5"}
{"id": "8", "testing_code": "assert sum_product([]) == (0, 1)\nassert sum_product([1, 1, 1]) == (3, 1)\nassert sum_product([100, 0]) == (100, 0)\nassert sum_product([3, 5, 7]) == (15, 105)\nassert sum_product([10]) == (10, 10)"}
{"id": "12", "testing_code": "assert longest([]) == ''\nassert longest(['x', 'y', 'z']) == 'x'\nassert longest(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'", "solution": "from typing import List, Optional\n\ndef longest(strings: List[str]) -> str:\n    if not strings:\n        return ''\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n\n", "text": "\n在字符串列表中，返回最长的字符串。如果有多个相同长度的字符串，\n则返回第一个。如果输入列表为空，则返回空。\n>>> longest([])\n\"\"\n>>> longest([\"a\", \"b\", \"c\"])\n\"a\"\n>>> longest([\"a\", \"bb\", \"ccc\"])\n\"ccc\""}
{"id": "31", "testing_code": "assert is_prime(6) == False\nassert is_prime(101) == True\nassert is_prime(11) == True\nassert is_prime(13441) == True\nassert is_prime(61) == True\nassert is_prime(4) == False\nassert is_prime(1) == False\nassert is_prime(5) == True\nassert is_prime(11) == True\nassert is_prime(17) == True\nassert is_prime(85) == False\nassert is_prime(77) == False\nassert is_prime(255379) == False\n"}
{"id": "37", "testing_code": "assert sort_even([1, 2, 3]) == [1, 2, 3]\nassert sort_even([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]\nassert sort_even([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]) == [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]"}
{"id": "53", "testing_code": "assert add(0, 1) == 1\nassert add(1, 0) == 1\nassert add(2, 3) == 5\nassert add(5, 7) == 12\nassert add(7, 5) == 12\nassert add(137,864) == 1001\nassert add(582,959) == 1541\nassert add(867,665) == 1532\nassert add(821,273) == 1094\nassert add(782,191) == 973\nassert add(64,578) == 642\nassert add(261,782) == 1043\nassert add(120,79) == 199\nassert add(507,863) == 1370\nassert add(779,843) == 1622\nassert add(460,320) == 780\nassert add(483,964) == 1447\nassert add(667,324) == 991\nassert add(388,257) == 645\nassert add(807,52) == 859"}
{"id": "72", "testing_code": "# Check some simple cases\nassert will_it_fly([3, 2, 3], 9)\nassert not will_it_fly([1, 2], 5)\nassert will_it_fly([3], 5)\nassert not will_it_fly([3, 2, 3], 1)\n\n\n# Check some edge cases that are easy to work out by hand.\nassert not will_it_fly([1, 2, 3], 6)\nassert will_it_fly([5], 5)"}
{"id": "47", "testing_code": "assert median([3, 1, 2, 4, 5]) == 3.0\nassert median([-10, 4, 6, 1000, 10, 20]) == 8.0\nassert median([5]) == 5.0\nassert median([6, 5]) == 5.5\nassert median([8, 1, 3, 9, 9, 2, 7]) == 7.0"}
{"id": "71", "testing_code": "# Check some simple cases\nassert triangle_area(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\nassert triangle_area(1, 2, 10) == -1.0\nassert triangle_area(4, 8, 5) == 8.18\nassert triangle_area(2, 2, 2) == 1.73\nassert triangle_area(1, 2, 3) == -1.0\nassert triangle_area(10, 5, 7) == 16.25\nassert triangle_area(2, 6, 3) == -1.0\n\n# Check some edge cases that are easy to work out by hand.\nassert triangle_area(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\nassert triangle_area(2, 2, 10) == -1.0"}
{"id": "75", "testing_code": "assert is_multiply_prime(5) == False\nassert is_multiply_prime(30) == True\nassert is_multiply_prime(8) == True\nassert is_multiply_prime(10) == False\nassert is_multiply_prime(125) == True\nassert is_multiply_prime(105) == True\nassert is_multiply_prime(126) == False\nassert is_multiply_prime(729) == False\nassert is_multiply_prime(891) == False\nassert is_multiply_prime(1001) == True"}
{"id": "90", "testing_code": "# Check some simple cases\nassert next_smallest([1, 2, 3, 4, 5]) == '2'\nassert next_smallest([5, 1, 4, 3, 2]) == '2'\nassert next_smallest([]) == ''\nassert next_smallest([1, 1]) == ''\nassert next_smallest([1,1,1,1,0]) == '1'\nassert next_smallest([1, 1]) == ''\nassert next_smallest([-35, 34, 12, -45]) == '-35'", "solution": "def next_smallest(lst):\n    lst = sorted(set(lst))\n    return '' if len(lst) < 2 else str(lst[1])", "text": "给你一个整数列表。编写一个next_smallest()函数，返回列表的第2个最小元素。\n如果没有此类元素，则返回空。\n\nnext_smallest([1, 2, 3, 4, 5]) == '2'\nnext_smallest([5, 1, 4, 3, 2]) == '2'\nnext_smallest([]) == ''\nnext_smallest([1, 1]) == ''\n"}
{"id": "95", "testing_code": "# Check some simple cases\nassert check_dict_case({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(check_dict_case({\"p\":\"pineapple\", \"b\":\"banana\"}))\nassert check_dict_case({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(check_dict_case({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\nassert check_dict_case({\"p\":\"pineapple\", \"5\":\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(check_dict_case({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\nassert check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\nassert check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \nassert check_dict_case({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(check_dict_case({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n# Check some edge cases that are easy to work out by hand.\nassert check_dict_case({}) == False, \"1st edge test error: \" + str(check_dict_case({}))"}
{"id": "108", "testing_code": "# Check some simple cases\nassert count_nums([]) == 0\nassert count_nums([-1, -2, 0]) == 0\nassert count_nums([1, 1, 2, -2, 3, 4, 5]) == 6\nassert count_nums([1, 6, 9, -6, 0, 1, 5]) == 5\nassert count_nums([1, 100, 98, -7, 1, -1]) == 4\nassert count_nums([12, 23, 34, -45, -56, 0]) == 5\nassert count_nums([-0, 1]) == 1\nassert count_nums([1]) == 1"}
{"id": "128", "testing_code": "# Check some simple cases\nassert prod_signs([1, 2, 2, -4]) == -9\nassert prod_signs([0, 1]) == 0\nassert prod_signs([1, 1, 1, 2, 3, -1, 1]) == -10\nassert prod_signs([2, 4,1, 2, -1, -1, 9]) == 20\nassert prod_signs([-1, 1, -1, 1]) == 4\nassert prod_signs([-1, 1, 1, 1]) == -4\nassert prod_signs([-1, 1, 1, 0]) == 0", "text": "提供一个整数数组arr，您需要返回\n整数的向量之和乘以数组中的每一个\n数字符号的乘积，符号用1、-1或0表示\n\n示例：\n>>> prod_signs([1, 2, 2, -4]) == -9\n>>> prod_signs([0, 1]) == 0\n", "solution": "def prod_signs(arr):\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])"}
{"id": "162", "testing_code": "# Check some simple cases\nassert string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\nassert string_to_md5('') == None\nassert string_to_md5('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\nassert string_to_md5('password') == '5f4dcc3b5aa765d61d8327deb882cf99'", "text": "给定一个字符串\"text\"，返回其等效的MD5哈希字符串2。\n如果\"text\"是一个空字符串，返回None。\n>>> string_to_md5(\"Hello world\") == \"3e25960a79dbc69b674cd4ec67a72c62\"\n", "solution": "def string_to_md5(text):\n    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None"}
{"id": "92", "testing_code": "assert any_int(2.0, 3.0, 1.0)==True, 'This prints if this assert fails 1 (good for debugging!)'\nassert any_int(2.5, 2.0, 3.0)==False, 'This prints if this assert fails 2 (good for debugging!)'\nassert any_int(1.5, 5.0, 3.5)==False, 'This prints if this assert fails 3 (good for debugging!)'\nassert any_int(2.0, 6.0, 2.0)==False, 'This prints if this assert fails 4 (good for debugging!)'\nassert any_int(4.0, 2.0, 2.0)==True, 'This prints if this assert fails 5 (good for debugging!)'\nassert any_int(2.2, 2.2, 2.2)==False, 'This prints if this assert fails 6 (good for debugging!)'\nassert any_int(-4.0, 6.0, 2.0)==True, 'This prints if this assert fails 7 (good for debugging!)'\n\n# Check some edge cases that are easy to work out by hand.\nassert any_int(2.0,1.0,1.0)==True, 'This prints if this assert fails 8 (also good for debugging!)'\nassert any_int(3.0,4.0,7.0)==True, 'This prints if this assert fails 9 (also good for debugging!)' ", "solution": "def any_int(x, y, z):\n    if x.is_integer() and y.is_integer() and z.is_integer():\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False"}
{"id": "103", "testing_code": "assert rounded_avg(1, 5) == '0b11'\nassert rounded_avg(7, 13) == '0b1010'\nassert rounded_avg(964,977) == '0b1111001010'\nassert rounded_avg(996,997) == '0b1111100100'\nassert rounded_avg(560,851) == '0b1011000010'\nassert rounded_avg(185,546) == '0b101101110'\nassert rounded_avg(362,496) == '0b110101101'\nassert rounded_avg(350,902) == '0b1001110010'\nassert rounded_avg(197,233) == '0b11010111'\n\n\n# Check some edge cases that are easy to work out by hand.\nassert rounded_avg(7, 5) == '-1'\nassert rounded_avg(5, 1) == '-1'\nassert rounded_avg(5, 5) == '0b101'\n", "solution": "def rounded_avg(n, m):\n    if m < n:\n        return \"-1\"\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation/(m - n + 1)))\n", "text": "给定两个正整数n和m，计算出\nn到m（包括n和m）之间整数的平均值。\n将答案四舍五入到最接近的整数，并将其转换为二进制并在字符串开头附上\"0b\"后返回。\n如果n大于m，则返回-1。\n举例:\nrounded_avg(1, 5) => \"0b11\"\nrounded_avg(7, 5) => \"-1\"\nrounded_avg(10, 20) => \"0b1111\"\nrounded_avg(20, 33) => \"0b11010\"\n"}
{"id": "148", "testing_code": "# Check some simple cases\nassert bf(\"Jupiter\", \"Neptune\") == [\"Saturn\", \"Uranus\"], \"First test error: \" + str(len(bf(\"Jupiter\", \"Neptune\")))      \nassert bf(\"Earth\", \"Mercury\") == [\"Venus\"], \"Second test error: \" + str(bf(\"Earth\", \"Mercury\"))  \nassert bf(\"Mercury\", \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"], \"Third test error: \" + str(bf(\"Mercury\", \"Uranus\"))      \nassert bf(\"Neptune\", \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"], \"Fourth test error: \" + str(bf(\"Neptune\", \"Venus\"))  \n\n\n# Check some edge cases that are easy to work out by hand.\nassert bf(\"Earth\", \"Earth\") == []\nassert bf(\"Mars\", \"Earth\") == []\nassert bf(\"Jupiter\", \"Makemake\") == []", "solution": "def bf(planet1, planet2):\n    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return []\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return list(planet_names[planet1_index + 1: planet2_index])\n    else:\n        return list(planet_names[planet2_index + 1 : planet1_index])", "text": "我们的太阳系中有八颗行星：最靠近太阳的是\n水星，接下来是金星，然后是地球，火星，木星，土星，天王星，海王星。\n编写一个函数，接受两个行星名称的字符串planet1和planet2作为参数。\n该函数应返回一个列表，其中包含位于planet1和planet2\n轨道之间的所有行星，按离太阳的近远排序。\n如果planet1或planet2不是正确的行星名称，\n则函数应返回一个空列表。\n\n示例：\nbf(\"Jupiter\", \"Neptune\") ==> [\"Saturn\", \"Uranus\"]\nbf(\"Earth\", \"Mercury\") ==> [\"Venus\"]\nbf(\"Mercury\", \"Uranus\") ==> [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"]\n"}
{"id": "125", "testing_code": "assert split_words('Hello world!') == ['Hello', 'world!']\nassert split_words('Hello,world!') == ['Hello', 'world!']\nassert split_words('Hello world,!') == ['Hello', 'world,!']\nassert split_words('Hello,Hello,world !') == ['Hello,Hello,world', '!']\nassert split_words('abcdef') == ['3']\nassert split_words('aaabb') == ['2']\nassert split_words('aaaBb') == ['1']\nassert split_words('') == ['0']", "solution": "def split_words(txt):\n    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.replace(',',' ').split()\n    else:\n        return [str(len([i for i in txt if i.islower() and ord(i)%2 == 0]))]", "text": "给定一个由单词组成的字符串，返回以空格分割的单词列表，\n如果不存在空格，你应该用逗号','分割；\n如果不存在逗号，你应该返回字母表中顺序号为奇数的小写字母的数量, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\nExamples\nsplit_words(\"Hello world!\") == [\"Hello\", \"world!\"]\nsplit_words(\"Hello,world!\") == [\"Hello\", \"world!\"]\nsplit_words(\"abcdef\") == [\"3\"] \n"}
{"id": "137", "testing_code": "assert compare_one(\"1\", \"2\") == \"2\"\nassert compare_one(\"1\", \"2.5\") == \"2.5\"\nassert compare_one(\"2\", \"3\") == \"3\"\nassert compare_one(\"5\", \"6\") == \"6\"\nassert compare_one(\"1\", '2,3') == '2,3'\nassert compare_one('5,1', '6') == '6'\nassert compare_one('1', '2') == '2'\nassert compare_one('1', \"1\") == \"\"", "solution": "def compare_one(a, b):\n    temp_a = float(a.replace(',','.'))\n    temp_b = float(b.replace(',','.'))\n    if float(temp_a) == float(temp_b): return \"\"\n    return a if float(temp_a) > float(temp_b) else b ", "text": "创建一个采用字符串表示实数的函数，\n并返回其中较大值对应的变量。\n如果值相等，则返回空字符串。\n注意：如果实数用字符串表示，则小数点可能是.或,\n\ncompare_one(\"1\", \"2.5\") == \"2.5\"\ncompare_one(\"1\", \"2,3\") == \"2,3\"\ncompare_one(\"5,1\", \"6\") == \"6\"\ncompare_one(\"1\", \"1\") == \"\"\n"}
{"id": "32", "testing_code": "assert find_zero([8, -8, -2, -7]) == 0.6516731880255975\nassert find_zero([4, 5, 10, 2, -4, -7, 5, -10]) == 1.0661071219365112\nassert find_zero([3, 9, -10, 4, -2, -3, 8, -7]) == -0.2540514511056244\nassert find_zero([-10, -10, -10, 10, 7, -10]) == -1.0662385823088698\nassert find_zero([-4, 3, -10, 6, -3, 4, 5, 7]) == 0.8680390336085111\nassert find_zero([1, -3, -3, 4]) == -0.7345008749980479\nassert find_zero([-10, 3, 7, 10, -7, -5]) == -2.1723359568277374\nassert find_zero([-7, 1, 6, 3, 6, -4]) == -0.8657208206714131\nassert find_zero([-1, 8, 5, 6, 2, 8]) == 0.1154504572623409\nassert find_zero([5, -3]) == 1.6666666666278616"}
{"id": "8", "testing_code": "assert sum_product([]) == (0, 1)\nassert sum_product([1, 1, 1]) == (3, 1)\nassert sum_product([100, 0]) == (100, 0)\nassert sum_product([3, 5, 7]) == (15, 105)\nassert sum_product([10]) == (10, 10)", "solution": "def sum_product(numbers: List[int]) -> List[int]:\n    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return [sum_value, prod_value]", "text": "对于给定的整数列表，返回一个由列表中所有整数的和及乘积组成的列表。\n空和应该等于0空积应该等于1。\n>>> sum_product([])\n[0, 1]\n>>> sum_product([1, 2, 3, 4])\n[10, 24]\n"}
{"id": "20", "solution": "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> List[float]:\n    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return list(closest_pair)", "text": "从提供的数字列表（长度至少为2）中选择并返回两个最接近的数字，并按顺序返回[小数字，大数字]。\n>>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n[2.0, 2.2]\n>>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n[2.0, 2.0]\n"}
{"id": "87", "solution": "def get_row(lst, x):\n    coords = [[i, j] for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n", "text": "你会得到一个作为嵌套列表的二维数据，\n它类似于矩阵，但与矩阵不同，每行可能包含不同数量的列。\n给定列表lst和整数x，在列表中查找整数x，\n并返回列表的列表，[[x1，y1]，[x2，y2]…]使得\n每个列表都是从0开始的一个坐标（行、列）。\n先按行升序对坐标进行排序。\n然后按列降序对行的坐标进行排序。\n\n示例：\nget_row([\n[1,2,3,4,5,6],\n[1,2,3,4,1,6],\n[1,2,3,4,5,1]\n], 1) == [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\nget_row([], 1) == []\nget_row([[], [1], [1, 2, 3]], 3) == [[2, 2]]\n"}
{"id": "107", "solution": "def even_odd_palindrome(n):\n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return [even_palindrome_count, odd_palindrome_count]", "text": "指定一个正整数，返回一个列表，其包含在1到n区间内（包括1和n）\n偶数整数回文和奇数整数回文的个数。\n\n示例1：\n\n输入：3\n输出：[1，2]\n说明：\n整数回文数是1、2、3，它们其中一个是偶数，两个是奇数。\n\n\n示例2：\n\n输入：12\n输出：[4，6]\n说明：\n整数回文数是1、2、3、4、5、6、7、8、9、11，其中4个是偶数，6个是奇数。\n\n\n注意：\n1. 1 <= n <= 10^3\n2. 返回的列表由分别具有偶数和奇数整数的回文数的个数组成。\n\n"}
{"id": "136", "testing_code": "assert largest_smallest_integers([2, 4, 1, 3, 5, 7]) == ['', '1']\nassert largest_smallest_integers([2, 4, 1, 3, 5, 7, 0]) == ['', '1']\nassert largest_smallest_integers([1, 3, 2, 4, 5, 6, -2]) == ['-2', '1']\nassert largest_smallest_integers([4, 5, 3, 6, 2, 7, -7]) == ['-7', '2']\nassert largest_smallest_integers([7, 3, 8, 4, 9, 2, 5, -9]) == ['-9', '2']\nassert largest_smallest_integers([]) == ['', '']\nassert largest_smallest_integers([0]) == ['', '']\nassert largest_smallest_integers([-1, -3, -5, -6]) == ['-1', '']\nassert largest_smallest_integers([-1, -3, -5, -6, 0]) == ['-1', '']\nassert largest_smallest_integers([-6, -4, -4, -3, 1]) == ['-3', '1']\nassert largest_smallest_integers([-6, -4, -4, -3, -100, 1]) == ['-3', '1']", "solution": "def largest_smallest_integers(lst):\n    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return [str(max(smallest)) if smallest else '', str(min(largest)) if largest else '']\n", "text": "创建返回列表[a，b]的函数，其中“a”为列表中\n最大的负整数，“b”是最小的的正整数。\n如果没有负整数或正整数，则返回为''。\n\n示例:\nlargest_smallest_integers([2, 4, 1, 3, 5, 7]) == ['', '1']\nlargest_smallest_integers([]) == ['', '']\nlargest_smallest_integers([0]) == ['', '']\n"}
{"id": "155", "solution": "def even_odd_count(num):\n    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return [even_count, odd_count]\n", "text": "给定一个整数，返回一个列表，其中分别有偶数数位和奇数数位的计数。\n\n示例:\neven_odd_count(-12) ==> [1, 1]\neven_odd_count(123) ==> [1, 2]\n"}
{"id": "151", "testing_code": "assert double_the_difference([]\n    ) == 0, 'This prints if this assert fails 1 (good for debugging!)'\nassert double_the_difference([5, 4]\n    ) == 25, 'This prints if this assert fails 2 (good for debugging!)'\nassert double_the_difference([0.1, 0.2, 0.3]\n    ) == 0, 'This prints if this assert fails 3 (good for debugging!)'\nassert double_the_difference([-10, -20, -30]\n    ) == 0, 'This prints if this assert fails 4 (good for debugging!)'\nassert double_the_difference([-1, -2, 8]\n    ) == 0, 'This prints if this assert fails 5 (also good for debugging!)'\nassert double_the_difference([0.2, 3, 5]\n    ) == 34, 'This prints if this assert fails 6 (also good for debugging!)'\nassert double_the_difference([-9, -7, -5, -3, -1, 1, 3, 5, 7, 9]\n    ) == 165, 'This prints if this assert fails 7 (good for debugging!)'", "solution": "def double_the_difference(lst):\n    out = 0\n    for i in lst:\n      try:\n        v = int(i)\n      except ValueError:\n        continue\n      if i <= 0 or i%2 == 0:\n        continue\n      out += v**2\n    return out\n"}
{"id": "112", "testing_code": "assert reverse_delete('abcde', 'ae') == ['bcd', 'False']\nassert reverse_delete('abcdef', 'b') == ['acdef', 'False']\nassert reverse_delete('abcdedcba', 'ab') == ['cdedc', 'True']\nassert reverse_delete('dwik', 'w') == ['dik', 'False']\nassert reverse_delete('a', 'a') == ['', 'True']\nassert reverse_delete('abcdedcba', '') == ['abcdedcba', 'True']\nassert reverse_delete('abcdedcba', 'v') == ['abcdedcba', 'True']\nassert reverse_delete('vabba', 'v') == ['abba', 'True']\nassert reverse_delete('mamma', 'mia') == ['', 'True']\n", "solution": "def reverse_delete(s,c):\n    s = ''.join([char for char in s if char not in c])\n    return [s,str(s[::-1] == s)]\n", "text": "任务：\n给定两个字符串s和c，你需要删除s中与c中任何字符相等的字符，\n然后检查结果字符串是否是回文串。\n回文串是指正向和反向读取都相同的字符串。\n你应该返回一个包含结果字符串和检查结果（True/False）两个元素的列表。\n示例：\n对于s = \"abcde\"，c = \"ae\"，结果应为[\"bcd\", False]。\n对于s = \"abcdef\"，c = \"b\"，结果应为[\"acdef\", False]。\n对于s = \"abcdedcba\"，c = \"ab\"，结果应为[\"cdedc\", True]。\n\n"}
{"id": "121", "testing_code": "assert sum_odd_in_even_position([5, 8, 7, 1]) == 12\nassert sum_odd_in_even_position([3, 3, 3, 3, 3]) == 9\nassert sum_odd_in_even_position([30, 13, 24, 321]) == 0\nassert sum_odd_in_even_position([5, 9]) == 5\nassert sum_odd_in_even_position([2, 4, 8]) == 0\nassert sum_odd_in_even_position([30, 13, 23, 32]) == 23\nassert sum_odd_in_even_position([3, 13, 2, 9]) == 3", "solution": "def sum_odd_in_even_position(lst):\n    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])", "text": "给定一个非空整数列表，返回位于偶数位置上的所有奇数元素的和。\n\n示例：\nsum_odd_in_even_position([5, 8, 7, 1]) ==> 12\nsum_odd_in_even_position([3, 3, 3, 3, 3]) ==> 9\nsum_odd_in_even_position([30, 13, 24, 321]) ==>0", "entry_fn_name": "sum_odd_in_even_position"}
{"id": "120", "testing_code": "assert k_maximum_elements([-3, -4, 5], 3) == [-4, -3, 5]\nassert k_maximum_elements([4, -4, 4], 2) == [4, 4]\nassert k_maximum_elements([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\nassert k_maximum_elements([123, -123, 20, 0, 1, 2, -3], 3) == [2, 20, 123]\nassert k_maximum_elements([-123, 20, 0, 1, 2, -3], 4) == [0, 1, 2, 20]\nassert k_maximum_elements([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\nassert k_maximum_elements([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\nassert k_maximum_elements([1, 0, 5, -7], 1) == [5]\nassert k_maximum_elements([4, -4], 2) == [-4, 4]\nassert k_maximum_elements([-10, 10], 2) == [-10, 10]\nassert k_maximum_elements([1, 2, 3, -23, 243, -400, 0], 0) == []", "solution": "def k_maximum_elements(arr, k):\n    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans", "entry_fn_name": "k_maximum_elements"}
{"id": "152", "testing_code": "assert compare_guess([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2]) == [0, 0, 0, 0, 3, 3\n    ], 'This prints if this assert fails 1 (good for debugging!)'\nassert compare_guess([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]) == [0, 0, 0, 0, 0, 0\n    ], 'This prints if this assert fails 1 (good for debugging!)'\nassert compare_guess([1, 2, 3], [-1, -2, -3]) == [2, 4, 6\n    ], 'This prints if this assert fails 1 (good for debugging!)'\nassert compare_guess([1, 2, 3, 5], [-1, 2, 3, 4]) == [2, 0, 0, 1\n    ], 'This prints if this assert fails 1 (good for debugging!)'", "solution": "def compare_guess(game,guess):\n    return [abs(x-y) for x,y in zip(game,guess)]", "text": "我认为我们都记得那种当一场期待已久的事件的结果最终揭晓时的感觉。\n你在那一刻所拥有的感受和想法绝对值得记录下来并进行比较。\n你的任务是确定一个人是否正确猜测了一系列比赛的结果。\n你将获得两个长度相等的数组，分别表示比分和猜测，每个索引表示一场比赛。\n返回一个相同长度的数组，表示每个猜测的误差有多大。如果他们猜对了，\n值为0，否则值为猜测与比分之间的绝对差值。\n\n示例:\n\ncompare_guess([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\ncompare_guess([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]", "entry_fn_name": "compare_guess"}
{"id": "23", "testing_code": "assert get_string_length('') == 0\nassert get_string_length('x') == 1\nassert get_string_length('asdasnakj') == 9", "solution": "def get_string_length(s: str) -> int:\n    return len(s)", "text": "返回给定字符串的长度。\n>>> get_string_length(\"\")\n0\n>>> get_string_length(\"abc\")\n3", "entry_fn_name": "get_string_length"}
